#Namaste React
#Episode1

## 1. What is Emmet?

Ans:Emmet is a plugin or developer tool kit that helps make your work faster and substantially enhances HTML and CSS workflows. Emmet is written in pure JavaScript and works across different platforms: web browser, Node.js, Microsoft WSH and Mozilla Rhino.

## 2.Difference between a Library and Framework?

Ans:Both the framework vs library is precoded support programs to develop complex software applications. However, libraries target a specific functionality, while a framework tries to provide everything required to develop a complete application.

## 3.What is CDN? Why do we use it?

Ans: The primary purpose of a content delivery network (CDN) is to reduce latency, or reduce the delay in communication created by a network's design.

## 4. Why is React known as React?

Ans: React is aptly named because: It "reacts" quickly to changes without reloading the whole page. It uses the virtual DOM to efficiently update parts of a webpage. It's built around components that "react" and update.

## 5.What is crossorigin in script tag?

Ans:The crossorigin attribute sets the mode of the request to an HTTP CORS Request. Web pages often make requests to load resources on other servers. Here is where CORS comes in. A cross-origin request is a request for a resource (e.g. style sheets, iframes, images, fonts, or scripts) from another domain.

## 6.What is diference between React and ReactDOM?

Ans:React is a JavaScript library for building User Interfaces and ReactDOM is the JavaScript library that allows React to interact with the DOM.

## 7.What is difference between react.development.js and react.production.js files via CDN?

Ans:In production mode, compression and minification of Javascript and other resources happens to reduce size of the code which is not the case when it comes to development mode. Performance will be much faster in production mode when compared to development mode.

## 8.What is async and defer?

Ans:Async downloads and executes JavaScript as soon as it's available, while defer attribute waits until the HTML document has been parsed before downloading and executing any external scripts.

#Episode2

## 9.What is `NPM`?

Ans:NPM downloads and executes JavaScript as soon as it's available.npm stands for Node Package Manager. It's a library and registry for JavaScript software packages.

## 10.What is `Parcel/Webpack`? Why do we need it?

Ans:Parcel/Webpack downloads and executes JavaScript as soon as it gets available.
Parcel automatically tracks all of the files, configuration, plugins, and dev dependencies that are involved in your build, and granularly invalidates the cache when something changes.
Webpack is a famous module builder that we extensively use during our Web Development Journey.

## 11.What is `.parcel-cache`?

Ans:`.parcel-cache` is a directory generated by the Parcel bundler, serving as a cache for storing intermediate build results. It enhances the development workflow by speeding up subsequent builds and optimizing resource usage.

## 12.What is `npx` ?

Ans:NPX stands for Node Package eXecute. It is simply an NPM package runner. It allows developers to execute any Javascript Package available on the NPM registry without even installing it.

## 13.What is difference between `dependencies` vs `devDependencies`?

Ans:"dependencies" : Packages required by your application in production.
"devDependencies" : Packages that are only needed for local development and testing.

## 14.What is Tree Shaking?

Ans:Tree shaking is a term commonly used within a JavaScript context to describe the removal of dead code.

## 15. What is Hot Module replacement?

Ans:Hot Module Replacement (HMR) exchanges, adds, or removes modules while an application is running, without a full reload.

## 16.List down your favourite 5 superpowers of Parcel and describe any 3 of them in your

own words.
Ans: 5 superpowers of Parcel:
HMR (Hot Module Replacement) - adds, or removes modules while an application is running, without a full reload.
File watcher algorithm - File Watchers monitor directories on the file system and perform specific actions when desired files appear.
Minification - Minification is the process of minimizing code and markup in your web pages and script files.
Image optimization
Caching while development

## 17.What is `.gitignore`? What should we add and not add into it?

Ans:The .gitignore file is a text file that tells Git which files or folders to ignore in a project during commit to the repository. The types of files you should consider adding to a .gitignore file are any files that do not need to get committed. for example, For security, the security key files and API keys should get added to the gitignore. package-lock.json should not add into your .gitignore file.

This is an example of what the .gitignore file could look like:

# Ignore Mac system files

.DS_store

# Ignore node_modules folder

node_modules

# Ignore all text files

\*.txt

# Ignore files related to API keys

.env

# Ignore SASS config files

.sass-cache

## 18.What is the difference between `package.json` and `package-lock.json`?

Ans:package.json:

This file is mandatory for every project
It contains basic information about the project
Application name/version/scripts.
It contains the version of your packages & libraries version, if you use ^ it upgrades the minor version of your project. if you use ~ it upgrades the major version of your project.
package-lock.json:

This file is automatically generated for those operations where npm modifies either the node_module tree or package-json.
It is generated after an npm install
It allows future devs & automated systems to download the same dependencies as the project.
it also allows to go back to the past version of the dependencies without actual ‘committing the node_modules folder.
It records the same version of the installed packages which allows to reinstall them. Future installs will be capable of building identical description tree.
it contains the version of your packages & versions. but it's name is package-lock, so it is locked your packages & libraries actual version , if you use 18.0.0 , it will show the actual version of the project.
~ or ^ in package.json file : These are used with the versions of the package installed.

## 19.Why should I not modify `package-lock.json`?

Ans:package-lock.json file contains the information about the dependencies and their versions used in the project. Deleting it would cause dependencies issues in the production environment. So don't modify it, It's being handled automatically by NPM.

## 20.What is `node_modules` ? Is it a good idea to push that on git?

Ans:node_modules folder like a cache for the external modules that your project depends upon. When you npm install them, they are downloaded from the web and copied into the node_modules folder and Nodejs is trained to look for them there when you import them (without a specific path). Don't push node_modulesin github because it contains lots of files(more than 100 MB), it will cost you memory space.

## 21.What is the `dist` folder?

Ans:The /dist folder contains the minimized version of the source code. The code present in the /dist folder is actually the code which is used on production web applications. Along with the minified code, the /dist folder also comprises of all the compiled modules that may or may not be used with other systems.

## 22.What is browserslist?

Ans:Browserslist is a tool that allows specifying which browsers should be supported in your frontend app by specifying "queries" in a config file. It's used by frameworks/libraries such as React, Angular and Vue, but it's not limited to them.

#Episode3

##23. What is JSX?
Ans: JSX stands for JavaScript XML.
JSX allows us to write HTML elements in JavaScript and place them in the DOM without any createElement() and/or appendChild() methods.
JSX makes it easier to write and add HTML in React.
JSX converts HTML tags into react elements.

### Example 1 using JSX:

```
const myElement = <h1>I Love Frontend!</h1>;
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(myElement);
```

### Example 2 Without JSX:

```
const myElement = React.createElement('h1', {}, 'I do not use JSX!');
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(myElement);
```

##24. Superpowers of JSX
Ans: Using JSX, you can write markup inside Javascript, providing you with a superpower to write logic and markup of a component inside a single .jsx file. JSX is easy to maintain and debug.

### Example

```
function greeting() {
//JSX
  return <h1> How are you!!!</h1>;
}
```

##25. Role of type attribute in script tag? What options can I use there?
Ans: The `type` attribute specifies the type of the script. The type attribute identifies the content between the `<script>` and `</script>` tags. It has a Default value which is “text/javascript”.

### `type` attribute can be of the following types:

- `text/javascript` : It is the basic standard of writing javascript code inside the `<script>` tag.
  ### Syntax
  ```
  <script type="text/javascript"></script>
  ```
- `text/ecmascript` : this value indicates that the script is following the `EcmaScript` standards.
- `module`: This value tells the browser that the script is a module that can import or export other files or modules inside it.
- `text/babel` : This value indicates that the script is a babel type and required bable to transpile it.
- `text/typescript`: As the name suggest the script is written in `TypeScript`.

#26. {TitleComponent} vs {<TitleComponent/>} vs
{<TitleComponent></TitleComponent>} in JSX

Ans: The Difference is stated below:

- `{TitleComponent}`: This value describes the `TitleComponent` as a javascript expression or a variable.
  The `{}` can embed a javascript expression or a variable inside it.
- `<TitleComponent/>` : This value represents a Component that is basically returning Some JSX value. In simple terms `TitleComponent` a function that is returning a JSX value.
  A component is written inside the `{<  />}` expression.
- `<TitleComponent></TitleComponent>` : `<TitleComponent />` and `<TitleComponent></TitleComponent>` are equivalent only when `< TitleComponent />` has no child components. The opening and closing tags are created to include the child components.

### Example

```
<TitleComponent>
    <FirstChildComponent />
    <SecondChildComponent />
    <ThirdChildComponent />
</TitleComponent>
```

##coding Assignment
Q. Create a Nested header Element using React.createElement(h1,h2,h3 inside a
div with class “title”)
```
const header = React.createElement("div",{className: "title",},[
React.createElement("h1",{className:"h1",key:"h1"},"This is h1 tag"),
React.createElement("h1",{className:"h2",key:"h3"},"This is h2 tag"),
React.createElement("h1",{className:"h3",key:"h3"},"This is h3 tag"),
])
```
Q. Create the same element using JSX
Ans:
```
const header = (<div className="title" key="title">

<h1 key="h1">This is h1 tag</h1>
<h2 key="h2">This is h2 tag</h2>
<h3 key="h3">This is h3 tag</h3>
</div>)
```
Q. Create a functional component of the same with JSX
Ans:
```
const header = function() {
return (<div className="title" key="title">

<h1 key="h1">This is h1 tag</h1>
<h2 key="h2">This is h2 tag</h2>
<h3 key="h3">This is h3 tag</h3>
  </div>)
};
```
Q. Composition of Component (Add a component inside another)
Ans:
```
const AnotherComponent = function() {
return (<div className="title" key="title">My Name is Bishnu Gorai</div>)
};

const Header = () => {
  return (
    <div className="Title" key="title">
      <h1 style={{color:"blue"}} key="h1">This is h1 tag</h1>
      <h2 style={{color:"palevioletred"}} key="h2">This is h2 tag</h2>
      <AnotherComponent/>
      <h3 style={{color:"green"}} key="h3">This is h3 tag</h3>
    </div>
  );
};
```
Q.{TitleComponent} vs {<TitleComponent/>} vs {<TitleComponent></TitleComponent>} in JSX.

Ans:
```
const element = <h1>This is React Element</h1>; // This is React element or {TitleComponent}

const TitleElement = () => {
  return <h2 style={{ color: "red" }}>This Title Element</h2>;
}; // This is Title Component

const Header = () => {
  return (
    <div className="Title" key="title">
      {/* This is {TitleComponent} */}
      {element}
      <h1 style={{ color: "blue" }} key="h1">
        This is h1 tag
      </h1>
      {/* This is {<TitleComponent/>} */}
      <TitleElement/>
      <h2 style={{ color: "palevioletred" }} key="h2">
        This is h2 tag
      </h2>
      {/* This is {<TitleComponent></TitleComponent>}*/}
      <TitleElement></TitleElement>
      <h3 style={{ color: "green" }} key="h3">
        This is h3 tag
      </h3>
    </div>
  );
};

```

Q.Create a Header Component from scratch using Functional Components with
JSX
○ Add a Logo on left
○ Add a search bar in middle
○ Add User icon on right
○ Add CSS to make it look nice

Ans:
```
const Header = () => {
    return(
        <>
        <header className="header">
            <div className="left">
                <img src={logo} alt="Logo" />
            </div>
            <div className="center">
                <input className="input" type="text" placeholder="Search anything you want..."/>
                <button type="submit">Submit</button>
            </div>
            <div className="right">
                <img src={userIcon} alt="User Icon"/>
            </div>
        </header>
        </>
    )
}

```